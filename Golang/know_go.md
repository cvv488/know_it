111

## TOC

[Slice](#Slice)
[Lang](#Lang)



# Slice

## При превышении длины среза исходного массива происходит интересное:

```go
	bArray := [1]byte {1} //исх массив
	bb := bArray[:] //срез на его основе

	bb = append(bb, 2)
	//при превышении создает новый срез с увеличенной емкостью и уже не указывает на исходный массив

	bArray[0] = 5 //bb уже это не видит!
```

Вывод: Всегда использовать срезы кроме фиксированных массивов
Срез может быть не только указателем на исходный массив, но и создать другой

## Можно создать и без make()

```go
var ee []byte
ee = append(ee, bb)
```

# LANG

Переменная с заглавной буквы станет публичной и будет видна другим пакетам

## iota - is enum
	каждый const обнуляет


## Литерал кода hex-символа

```go
	snn := "\x50" //as string "P"
	snn = "\x00" // as "\0"
```

## DateTime

при невалидных компонентах dt паники не будет - результат просто сдвинется

```go
	datett := time.Date(2000, 1, 33, 0, 0, 0, 0, time.UTC) //2000-02-02 00:00:00 +0000 UTC
```

